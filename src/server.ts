import type { Server, ServerWebSocket } from "bun";
import { getCertManager } from "./core/cert-manager.ts";
import { getConfigManager } from "./core/config-manager.ts";
import { getDockerClient } from "./core/docker-client.ts";
import { type ResolvedRoute, getProxyRouter } from "./core/proxy-router.ts";
import { handleApiRequest } from "./server/routes/index.ts";
import { getBindAddress } from "./types/config.ts";
import { CertNotInitializedError, PortBindError } from "./types/errors.ts";
import { logger } from "./utils/logger.ts";

// Import embedded assets (generated by build.ts)
// Using dynamic import to handle case where assets haven't been built yet
let embeddedAssets: Record<string, string> = {};
try {
  const assets = await import("./ui/embedded-assets.ts");
  embeddedAssets = assets.embeddedAssets;
} catch {
  // Assets not built yet - will serve placeholder
}

/**
 * WebSocket proxy state attached to each client connection
 */
interface WebSocketProxyState {
  upstream: WebSocket | null;
  targetHost: string;
  targetPort: number;
}

let httpsServer: Server<WebSocketProxyState> | null = null;
let httpServer: Server<undefined> | null = null;

/**
 * Start the proxy server
 * Runs in foreground - use Ctrl+C or SIGTERM to stop
 */
export async function startProxyServer(): Promise<void> {
  const configManager = getConfigManager();
  const certManager = getCertManager();
  const router = await getProxyRouter();

  const config = await configManager.get();
  const bindAddress = getBindAddress(config);

  // Verify certificates exist
  const certsValid = await certManager.validateCerts();
  if (!certsValid) {
    throw new CertNotInitializedError();
  }

  const tlsOptions = await certManager.getTLSOptions();

  // Start HTTPS server
  httpsServer = startHttpsServer({
    port: config.proxy.https_port,
    hostname: bindAddress,
    tls: tlsOptions,
    dockerNetwork: config.docker_network,
  });

  // Start HTTP redirect server
  httpServer = startHttpRedirectServer({
    httpPort: config.proxy.http_port,
    httpsPort: config.proxy.https_port,
    hostname: bindAddress,
  });

  logger.info("Proxy listening on:");
  logger.info(`  HTTPS: https://${bindAddress}:${config.proxy.https_port}`);
  logger.info(`  HTTP:  http://${bindAddress}:${config.proxy.http_port} (redirects to HTTPS)`);
  logger.info(`  Dashboard: https://${router.getDashboardHostname()}`);

  // Log registered routes
  const routes = router.getRoutes();
  if (routes.size > 0) {
    logger.info("");
    logger.info("Registered routes:");
    for (const [hostname, route] of routes) {
      logger.info(`  https://${hostname} -> ${route.containerName}:${route.port}`);
    }
  } else {
    logger.info("");
    logger.warn("No target routes configured. Install a target with: katana install <target>");
  }

  logger.info("");
  logger.info("Press Ctrl+C to stop the proxy");

  // Handle graceful shutdown
  const shutdown = () => {
    logger.info("");
    logger.info("Shutting down proxy...");
    httpsServer?.stop();
    httpServer?.stop();
    process.exit(0);
  };

  process.on("SIGINT", shutdown);
  process.on("SIGTERM", shutdown);
}

interface HttpsServerOptions {
  port: number;
  hostname: string;
  tls: { cert: string; key: string; ca?: string };
  dockerNetwork: string;
}

function startHttpsServer(options: HttpsServerOptions): Server<WebSocketProxyState> {
  const { port, hostname, tls, dockerNetwork } = options;

  try {
    return Bun.serve({
      port,
      hostname,
      tls: {
        cert: tls.cert,
        key: tls.key,
        // Note: Don't pass `ca` here - it enables client certificate verification
      },

      async fetch(req, server) {
        const hostname = req.headers.get("host") || "";
        const router = await getProxyRouter();
        const routeResult = router.resolve(hostname);

        switch (routeResult.type) {
          case "dashboard":
            return handleDashboard(req);

          case "target": {
            // Check for WebSocket upgrade
            if (req.headers.get("upgrade")?.toLowerCase() === "websocket") {
              return handleWebSocketUpgrade(req, server, routeResult.route, dockerNetwork);
            }
            return proxyHttpRequest(req, routeResult.route, dockerNetwork);
          }

          case "not_found":
            return new Response(
              htmlPage(
                "404 - Target Not Found",
                `<p>No target configured for hostname: <code>${escapeHtml(hostname)}</code></p>
                <p>Available commands:</p>
                <ul>
                  <li><code>katana list</code> - List available targets</li>
                  <li><code>katana install &lt;target&gt;</code> - Install a target</li>
                </ul>`,
              ),
              {
                status: 404,
                headers: { "Content-Type": "text/html" },
              },
            );
        }
      },

      websocket: {
        message(ws: ServerWebSocket<WebSocketProxyState>, message) {
          // Forward message to upstream
          const state = ws.data;
          if (state.upstream?.readyState === WebSocket.OPEN) {
            state.upstream.send(message);
          }
        },

        close(ws: ServerWebSocket<WebSocketProxyState>) {
          // Close upstream connection
          const state = ws.data;
          state.upstream?.close();
        },

        open(_ws: ServerWebSocket<WebSocketProxyState>) {
          // Connection opened - upstream setup happens in upgrade handler
        },
      },

      error(error) {
        logger.error("Server error:", error);
        return new Response("Internal Server Error", { status: 500 });
      },
    });
  } catch (error: unknown) {
    const err = error as { code?: string };
    if (err.code === "EACCES") {
      throw new PortBindError(port, "Permission denied");
    }
    if (err.code === "EADDRINUSE") {
      throw new PortBindError(port, "Port already in use");
    }
    throw error;
  }
}

/**
 * Handle HTTP-to-HTTPS redirect server
 */
function startHttpRedirectServer(options: {
  httpPort: number;
  httpsPort: number;
  hostname: string;
}): Server<undefined> {
  try {
    return Bun.serve({
      port: options.httpPort,
      hostname: options.hostname,

      fetch(req) {
        const url = new URL(req.url);
        const httpsUrl = `https://${url.hostname}${options.httpsPort === 443 ? "" : `:${options.httpsPort}`}${url.pathname}${url.search}`;

        return Response.redirect(httpsUrl, 301);
      },

      error() {
        return new Response("Redirect to HTTPS", { status: 500 });
      },
    });
  } catch (error: unknown) {
    const err = error as { code?: string };
    if (err.code === "EACCES") {
      throw new PortBindError(options.httpPort, "Permission denied");
    }
    if (err.code === "EADDRINUSE") {
      throw new PortBindError(options.httpPort, "Port already in use");
    }
    throw error;
  }
}

/**
 * Handle dashboard requests
 * Routes: API endpoints, static files, or SPA fallback
 */
async function handleDashboard(req: Request): Promise<Response> {
  const url = new URL(req.url);
  const pathname = url.pathname;

  // API routes
  if (pathname.startsWith("/api/")) {
    const response = await handleApiRequest(req);
    if (response) {
      return response;
    }
    // Unknown API route
    return Response.json({ success: false, error: "Not found" }, { status: 404 });
  }

  // Static files (js, css, images)
  if (pathname.match(/\.(js|css|ico|png|svg|woff2?)$/)) {
    return serveStaticFile(pathname);
  }

  // SPA fallback - serve index.html for all other routes
  return serveIndexHtml();
}

/**
 * Serve static files from embedded assets
 */
function serveStaticFile(pathname: string): Response {
  // Determine content type
  const ext = pathname.split(".").pop()?.toLowerCase();
  const contentTypes: Record<string, string> = {
    js: "application/javascript",
    css: "text/css",
    ico: "image/x-icon",
    png: "image/png",
    svg: "image/svg+xml",
    woff: "font/woff",
    woff2: "font/woff2",
  };
  const contentType = contentTypes[ext ?? ""] ?? "application/octet-stream";

  // Get filename without leading slash
  const filename = pathname.replace(/^\//, "");

  // Check embedded assets first (works in compiled binary)
  if (embeddedAssets[filename]) {
    return new Response(embeddedAssets[filename], {
      headers: { "Content-Type": contentType },
    });
  }

  // 404 if not found
  return new Response("Not Found", { status: 404 });
}

/**
 * Serve the main index.html page
 */
function serveIndexHtml(): Response {
  // Check embedded assets first (works in compiled binary)
  if (embeddedAssets["index.html"]) {
    return new Response(embeddedAssets["index.html"], {
      headers: { "Content-Type": "text/html" },
    });
  }

  // Serve placeholder if UI not built
  return new Response(getPlaceholderHtml(), {
    headers: { "Content-Type": "text/html" },
  });
}

/**
 * Placeholder HTML shown when UI is not built
 */
function getPlaceholderHtml(): string {
  return `<!DOCTYPE html>
<html>
<head>
  <title>Katana Dashboard</title>
  <style>
    body {
      font-family: system-ui, -apple-system, sans-serif;
      max-width: 800px;
      margin: 40px auto;
      padding: 0 20px;
      line-height: 1.6;
      color: #333;
    }
    h1 { color: #1a1a1a; margin-bottom: 0.5em; }
    .status {
      padding: 20px;
      background: #f5f5f5;
      border-radius: 8px;
      margin: 20px 0;
    }
    code {
      background: #e8e8e8;
      padding: 2px 6px;
      border-radius: 4px;
      font-family: 'SF Mono', Monaco, monospace;
    }
    pre {
      background: #e8e8e8;
      padding: 12px;
      border-radius: 6px;
      overflow-x: auto;
    }
    ul { padding-left: 20px; }
    li { margin: 8px 0; }
  </style>
</head>
<body>
  <h1>Katana Dashboard</h1>
  <div class="status">
    <p>The web dashboard UI has not been built yet.</p>
    <p>Build the UI with:</p>
    <pre><code>bun run build:ui</code></pre>
    <p>Or use the CLI to manage targets:</p>
    <ul>
      <li><code>katana status</code> - View system status</li>
      <li><code>katana list</code> - List available targets</li>
      <li><code>katana install &lt;target&gt;</code> - Install a target</li>
    </ul>
  </div>
  <p style="color: #666; font-size: 0.9em;">
    Katana is the lab management solution for OWASP SamuraiWTF.
  </p>
</body>
</html>`;
}

/**
 * Proxy an HTTP request to a container
 */
async function proxyHttpRequest(
  req: Request,
  route: ResolvedRoute,
  networkName: string,
): Promise<Response> {
  const docker = getDockerClient();

  // Get container IP
  const containerIP = await docker.getContainerIPOnNetwork(route.containerName, networkName);

  if (!containerIP) {
    // Check if container is running
    const isRunning = await docker.isContainerRunning(route.containerName);
    if (!isRunning) {
      return new Response(
        htmlPage(
          "503 - Target Not Running",
          `<p>Container <code>${escapeHtml(route.containerName)}</code> is not running.</p>
          <p>Start it with:</p>
          <pre><code>katana start ${escapeHtml(route.targetName)}</code></pre>`,
        ),
        {
          status: 503,
          headers: { "Content-Type": "text/html" },
        },
      );
    }

    return new Response(
      htmlPage(
        "502 - Bad Gateway",
        `<p>Container <code>${escapeHtml(route.containerName)}</code> is not reachable on network <code>${escapeHtml(networkName)}</code>.</p>
        <p>Try restarting the target:</p>
        <pre><code>katana stop ${escapeHtml(route.targetName)} && katana start ${escapeHtml(route.targetName)}</code></pre>`,
      ),
      {
        status: 502,
        headers: { "Content-Type": "text/html" },
      },
    );
  }

  // Build target URL
  const originalUrl = new URL(req.url);
  const targetUrl = `http://${containerIP}:${route.port}${originalUrl.pathname}${originalUrl.search}`;

  // Clone headers, removing hop-by-hop headers
  const headers = new Headers(req.headers);
  headers.delete("host");
  headers.set("host", `${containerIP}:${route.port}`);
  headers.delete("connection");
  headers.delete("keep-alive");
  headers.delete("transfer-encoding");
  headers.delete("te");
  headers.delete("trailer");
  headers.delete("upgrade");

  // Add X-Forwarded headers
  headers.set("x-forwarded-for", req.headers.get("x-real-ip") || "127.0.0.1");
  headers.set("x-forwarded-proto", "https");
  headers.set("x-forwarded-host", req.headers.get("host") || "");

  try {
    // Forward request to container
    // Use decompress: false to pass through compressed responses transparently
    // This is important for security testing - we want minimal modification of traffic
    const response = await fetch(targetUrl, {
      method: req.method,
      headers,
      body: req.body,
      redirect: "manual", // Don't follow redirects - return them to client
      decompress: false, // Don't auto-decompress - pass through as-is
    });

    // Clone response headers
    const responseHeaders = new Headers(response.headers);
    responseHeaders.delete("transfer-encoding"); // Bun handles this

    return new Response(response.body, {
      status: response.status,
      statusText: response.statusText,
      headers: responseHeaders,
    });
  } catch (error: unknown) {
    const err = error as Error;
    logger.error(`Proxy error for ${route.containerName}:`, err.message);

    return new Response(
      htmlPage(
        "502 - Bad Gateway",
        `<p>Could not connect to <code>${escapeHtml(route.containerName)}</code></p>
        <p>Error: ${escapeHtml(err.message)}</p>`,
      ),
      {
        status: 502,
        headers: { "Content-Type": "text/html" },
      },
    );
  }
}

/**
 * Handle WebSocket upgrade and proxy
 */
async function handleWebSocketUpgrade(
  req: Request,
  server: Server<WebSocketProxyState>,
  route: ResolvedRoute,
  networkName: string,
): Promise<Response | undefined> {
  const docker = getDockerClient();

  // Get container IP
  const containerIP = await docker.getContainerIPOnNetwork(route.containerName, networkName);

  if (!containerIP) {
    return new Response("Target not available", { status: 503 });
  }

  const originalUrl = new URL(req.url);
  const wsUrl = `ws://${containerIP}:${route.port}${originalUrl.pathname}${originalUrl.search}`;

  // Create state for this connection
  const state: WebSocketProxyState = {
    upstream: null,
    targetHost: containerIP,
    targetPort: route.port,
  };

  // Upgrade the client connection
  const upgraded = server.upgrade(req, {
    data: state,
  });

  if (!upgraded) {
    return new Response("WebSocket upgrade failed", { status: 500 });
  }

  // Connect to upstream WebSocket
  // Note: This is a simplified implementation. For production,
  // we'd need to handle the upstream connection more carefully
  // and properly bridge the two connections.
  try {
    const upstream = new WebSocket(wsUrl);

    upstream.onopen = () => {
      state.upstream = upstream;
    };

    upstream.onmessage = (event) => {
      // We need to forward to client, but we don't have a reference
      // to the client WebSocket here. This is a limitation of this approach.
      // A more robust solution would be to store connections in a map.
    };

    upstream.onclose = () => {
      state.upstream = null;
    };

    upstream.onerror = (error) => {
      logger.error("WebSocket upstream error:", error);
    };
  } catch (error) {
    logger.error("Failed to connect to upstream WebSocket:", error);
  }

  return undefined; // Bun handles the upgrade
}

/**
 * Generate HTML page wrapper
 */
function htmlPage(title: string, content: string): string {
  return `
<!DOCTYPE html>
<html>
<head>
  <title>${escapeHtml(title)} - Katana</title>
  <style>
    body {
      font-family: system-ui, -apple-system, sans-serif;
      max-width: 600px;
      margin: 60px auto;
      padding: 0 20px;
      line-height: 1.6;
      color: #333;
    }
    h1 { color: #c00; margin-bottom: 0.5em; }
    code {
      background: #f0f0f0;
      padding: 2px 6px;
      border-radius: 4px;
      font-family: 'SF Mono', Monaco, monospace;
    }
    pre {
      background: #f0f0f0;
      padding: 12px;
      border-radius: 6px;
      overflow-x: auto;
    }
    pre code { background: none; padding: 0; }
  </style>
</head>
<body>
  <h1>${escapeHtml(title)}</h1>
  ${content}
</body>
</html>
`;
}

/**
 * Escape HTML entities
 */
function escapeHtml(str: string): string {
  return str
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;");
}
